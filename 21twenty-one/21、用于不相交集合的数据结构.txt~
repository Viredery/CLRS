不相交集合数据结构保持一组不相交的动态集合S={S1,S2,...,Sk},每个集合通过一个代表来识别，代表即集合中的某个成员

MAKE-SET(x)
UNIOIN(x,y)
FIND-SET(x)

1、链表表示：
结点x的域：data数据,next指向x的下一个结点,rep指向x所在集合的代表
集合：head,tail,size
合并操作就是将x所在链表拼接到y所在链表的表尾(tail[y])
加权合并启发式策略：假设每个表中还包括了表的长度，并且总是把较短的表拼到较长的表上去；如果两个表一样长的话，可以任意拼接
m个MAKE-SET(x)，UNIOIN(x,y)，FIND-SET(x)操作的一个序列（其中n个是MAKE-SET(x)操作）要花O(m+nlgn)的时间

2、不相交集合森林：
结点x的域:data数据，parent指向x的父亲的结点，rank秩（表示结点高度的一个上界）
集合：root
树中每个结点都包含集合的一个成员，每棵树表示一个集合。每个成员仅指向其父结点。每棵树的根包含了代表，并且是它自己的父结点
启发式策略：
1）按秩合并：
       对每个结点，用秩表示结点高度的一个上界
2）路径压缩：
       使FIND-SET(x)查找的每个结点都直接指向根结点（路径压缩不改变结点的秩）

当同时使用按秩合并和路径压缩时，最坏情况运行时间为O(m*α(n))，其中α(n)是一个增长极其缓慢的函数
