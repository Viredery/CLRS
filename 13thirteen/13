红黑树（二叉查找树的一种）：在最坏情况下，基本动态集合操作的时间为O(lgn)

如果某结点没有一个子结点或父结点，则该结点相应的指针（p）域包含值NIL。这些NIL为指向二叉查找树的外结点（叶子）的指针，而把带关键字的结点视为树的内结点。

       通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍。
       一棵有n个内结点的红黑树的高度至多为2lg(n+1)
(a)每个结点或是红的，或是黑的
(b)根结点是黑的
(c)每个叶结点（NIL）是黑的
(d)如果一个结点是红的，则它的两个儿子是黑的
(e)对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点

RB-INSERT-FIXUP(z)										每次循环的开始z始终为红色
while p[z]是红色的
   do if p[z]是p[p[z]]的左孩子
	 then  令y为p[p[z]]的右孩子（z的叔叔）
               if y是红色的
                  then  z的父亲和叔叔由红变黑，z的父亲的父亲由黑变红，令z向上移至z父亲的父亲	情况一，x上移后继续循环
                  else  if z为右孩子
                           then  以p[z]为结点左旋，令z为z的左孩子				情况二，将z，p[z],p[p[z]转换为一条线，变成情况三
                        p[z]变黑，p[p[z]变红，同时以p[p[z]为结点右旋				情况三，执行后p[z]为黑色，退出循环
         else  与上面过程相同，只是将上面的左、右交换
root的颜色变为黑										z为root时p[z]为黑，退出循环的情况下，保证性质2


RB-DELETE-FIXUP(x)										每次循环的开始x始终携带一重黑色
while x不是根且x是黑色的
   do if x是左孩子
         then  令w为right[p[x]](x的兄弟)
               if w是红色的									情况一，执行后进入二，三，四中的一个
                  then  w变为黑，p[x]变为红，以p[x]为结点左旋，确定新的w
               if w的两个孩子都是黑色的
                  then  让w变为红，x上移至p[x]							情况二，x上移后继续循环
                  else  if w右孩子是黑色的
                           then  让w变红，w左孩子变黑，以w为结点右旋，确定新的w			情况三，执行后转变为情况四
                        w颜色变为p[x]的，p[x]和w右孩子变为黑，以p[x]为结点左旋，令x为root		情况四，执行后退出循环
         else  与上面过程相同，只是将上面的左、右交换
x的颜色变为黑											当x因为x是红而退出时，将x携带的一重黑色变为x的颜色


