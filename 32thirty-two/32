朴素法：
    对n-m+1个可能的每一个s值检查条件P[1..m] = T[s+1,..,s+m]
    预处理时间0，匹配时间O((n-m+1)m)
Rabin-Karp算法：
    将字符转换为数字，然后（取模后）进行数字的比较
    预处理时间O(m)，匹配时间O((n-m+1)m)
有限自动机算法：
    定义一个变迁函数δ(q,a)=σ(Pq+a)
        σ(x)是x的后缀P的最长前缀的长度
    预处理时间O(m*字母表的字母数)，匹配时间O(n)
Knuth-Morris-Pratt算法：
    模式P的前缀函数π(q) = max{k:k<q且Pk是Pq的后缀}
    预处理时间O(m)，匹配时间O(n)
