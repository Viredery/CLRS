表示一个图G(V,E)，有两种标准的方法，即邻接表（适合稀疏图）和邻接矩阵（适合稠密图）
邻接表：存储空间为O(V+E)
邻接矩阵：存储空间为O(V方)

两者均可表示加权图

广度优先搜索breadth-first search
    使用邻接表时：O(V+E)
    广度优先搜索的正确性：设G=(V,E)是一个有向图或无向图，并假设过程BFS从G上某个给定点s属于V开始运行。那么，在执行过程中，BFS可以发现新源点s可达的每一个顶点v属于V。在运行终止时，对所有v属于V，都有d[v]=δ(s,v)（从顶点s到顶点v的任何路径中的最少的边数，具有δ(s,v)的路径即为s到v的最短路径）。此外，对任意从s可达的顶点v≠s，从s到v的最短路径之一是从s到pi[v]的最短路径再加上边(pi[v],v)
   广度优先树
   赋值给顶点u的值d[u]与顶点在邻接表中的次序无关。由BFS计算出来的广度优先树与邻接表中的顺序是有关的
    边的分类：
        有向图：树边、反向边、交叉边
        无向图：树边、交叉边
   BFS应用：
       1）求树的直径：树的直径是树中所有最短路径长度的最大值。有效算法为以任意顶点w开始，先做一次BFS，找到最远顶点u，然后再以此点u进行一次BFS，找到最远顶点v，此时，u到v的路径长度就是树的直径


深度优先搜索
    创建一个深度优先森林；为每个顶点加盖时间戳
    （对DFS修改，使之遇到图中的边的时对其进行分类）
    使用邻接表时：O(V+E)
    深度优先搜索的性质：
        1、括号定理 2、后裔区间嵌套 3、白色路径定理
    边的分类：
        有向图：树边、反向边、正向边、交叉边
        无向图：树边、反向边
    对于无向图：
        对一个无向图进行深度优先搜索的时，不会出现正向边和交叉边
        对无向图G的深度优先搜索可以用来识别G的连通分支，且深度优先森林中所包含的树的数量与G中的连通分支的数量一样多
    DFS应用：
        1）拓扑排序：对dag进行拓扑排序，得到该图所有顶点的一个线性排序，满足如果G包含边(u,v)，则在该序列中，u就出现在v前面（如果图有回路则不可能存在这样的线性序列）。算法为各个顶点按照完成时间的降序顺序，从左向右排序
          一个有向图是无回路的，当且仅当对G进行深度优先搜索时没有得到反向边
          若有向图是有回路的，则拓扑排序能产生一个顶点排序，它可以最小化“坏边”的数目。坏边即那些与生成的顶点序列不一致的边
        2）求G的强连通分支。把G的每个强连通子图缩减为每个分支只有单个顶点所得到的无回路子图G(SCC)。算法实现为对G和G的转置各做一次深度优先搜索，其中G的转置中顶点按照完成时间的降序顺序访问。


定义：
单连通：在一个有向图G=(V,E)中，如果u→v蕴含着对所有顶点u、v属于V，至多有一条从u到v的简单路径，则称G是单连通的
强连通分支：有向图G=(V,E)中的一个最大的顶点集合C属于V，对于C中的每一对顶点u和v，有u→v和v→u
（连通分支）
半连通：有向图G=(V,E)，如果对所有顶点u、v属于V，都有u→v或v→u，则图G称为半连通
有向无回图dag
挂载点：设G=(V,E)是一个无向连接图，如果去掉G的某个顶点后G就不再是连通图了，这样的顶点称为挂载点
桥：设G=(V,E)是一个无向连接图，如果去掉某一边后，G就不再成为连通图了，这样的边称为桥
双连通分支：一个最大边集，该集合中的任意两条边都位于同一个公共简单回路上
有向强连通图的欧拉回路：通过G中每条边仅一次（但可以访问某个顶点多次）的一个回路
    图G具有欧拉回路，当且仅当每一个顶点u属于V的入度和出度相等
