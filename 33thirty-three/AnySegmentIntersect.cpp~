#include<iostream>
#define ERROR_NOT_EXIST 1
using namespace std;
struct Point
{
	int x;
	int y;
	bool left;
	Segment *s;
};
class Segment
{
public:
	Segment(int x1,int y1,int x2,int y2);
	Segment(Segment &s);
	Point left;
	Point right;
	~Segment(){}
	bool operator<(Segment &s);
	bool operator!=(Segment &s);
};
Segment::Segment(int x1,int y1,int x2,int y2)
{
	if(x1 > x2)
	{
		int tmp1 = x1; x1 = x2; x2 = tmp1;
		tmp1 = y1; y1 = y2; y2 = tmp1;
	}else if(x1 == x2){
		if(y1 > y2)
		{
			int tmp2 = y1; y1 = y2; y2 = tmp2;
		}
	}
	left.x = x1;
	left.y = y1;
	left.left = true;
	right.x = x2;
	right.y = y2;
	right.left = false;
	left.s = right.s = this;
}
Segment::Segment(Segment &s)
{
	left.x = s.left.x;
	left.y = s.left.y;
	left.left = true;
	right.x = s.right.x;
	right.y = s.right.y;
	right.left = false;
	left.s = right.s = this;
}
bool Segment::operator<(Segment &s)
{
	int x = s.left.x;
	int y = 
}
bool Segment::operator!=(Segment &s)
{
	if( left.x != s.left.x || left.y != s.left.y || right.x = s.right.x || right.y = s.right.y)
		return true;
	return false;
}


struct Node
{
	Segment data;
	bool color;
	Node *parent;
	Node *left;
	Node *right;
};
static const int BLACK = 1;
static const int RED = 0;
class RedBlackTree
{
public:
	RedBlackTree();
	void Insert(Segment data);
	void Delete(Segment data);
	Node *Search(Segment data);
	Node *Successor(Segment data);
	Node *Predecessor(Segment data);
private:
	Node *root;
	Node *nil;
	Node *Minimum(Node *node);
	void LeftRotate(Node *x);
	void RightRotate(Node *x);
	void RBDelete(Node *x);
	void RBInsert(Node *x);
};
RedBlackTree::RedBlackTree()
{
	nil = new Node;
	nil->color = BLACK;
	root = nil;
}
void RedBlackTree::Insert(Segment data)
{
	Node *newNode = new Node;
	newNode->data(data);
	newNode->color = RED;
	newNode->left = newNode->right = nil;
	Node *x = root;		//x为当前访问的结点
	Node *y = nil;		//y为当前访问的结点的双亲
	while(x != nil)		//当x为nil时，y即为应被插入的位置的结点的双亲
	{
		y = x;
		if(x->data < data)
			x = x->right;
		else
			x = x->left;
	}
	newNode->parent = y;	//设置新结点的双亲为y
	if(y == nil)		//设置y指向新结点
		root = newNode;
	else if(y->data < data)
		y->right = newNode;
	else
		y->left = newNode;
	RBInsert(newNode);	//调整以保证红黑树的性质不被破坏
}
void RedBlackTree::RBInsert(Node *node)
{
	while(node->parent->color == RED)
	{
		if(node->parent == node->parent->parent->left)
		{
			Node *uncle = node->parent->parent->right;
			if(uncle->color == RED)
			{
				node->parent->color = uncle->color = BLACK;
				uncle->parent->color = RED;
				node = uncle->parent;
			}else{
				if(node == node->parent->right)
				{
					LeftRotate(node->parent);
					node = node->left;
				}
			node->parent->parent->color = RED;
				node->parent->color = BLACK;
				RightRotate(node->parent->parent);
			}
		}else{
			Node *uncle = node->parent->parent->left;
			if(uncle->color == RED)
			{
				node->parent->color = uncle->color = BLACK;
				uncle->parent->color = RED;
				node = uncle->parent;
			}else{
				if(node == node->parent->left)
				{
					RightRotate(node->parent);
					node = node->right;
				}
				node->parent->parent->color = RED;
				node->parent->color = BLACK;
				LeftRotate(node->parent->parent);
			}
		}
	}
	root->color = BLACK;
}
void RedBlackTree::Delete(Segment data)
{
	Node *nodeTarget = Search(data);
	if(nodeTarget == nil)
		throw ERROR_NOT_EXIST;
	Node *nodeDeleted;
	Node *nodeChild;

	if(nodeTarget->left == nil || nodeTarget->right == nil)	//确定应被删除的结点
		nodeDeleted = nodeTarget;
	else
		nodeDeleted = Successor(data);

	if(nodeDeleted->left != nil)		//确定应被删除的结点的孩子（至多一个，如果没有则nodeChild等于nil）
		nodeChild = nodeDeleted->left;
	else
		nodeChild = nodeDeleted->right;

	nodeChild->parent = nodeDeleted->parent;	//连接待删除的结点的双亲和孩子
	if(nodeDeleted->parent == nil)
		root = nodeChild;
	else if(nodeDeleted == nodeDeleted->parent->left)
		nodeDeleted->parent->left = nodeChild;
	else
		nodeDeleted->parent->right = nodeChild;

	if(nodeDeleted != nodeTarget)
		nodeTarget->data = nodeDeleted->data;

	if(nodeDeleted->color == BLACK)		//调整已保持红黑树的性质
		RBDelete(nodeChild);
	delete nodeDeleted;
}
void RedBlackTree::RBDelete(Node *node)
{
	while(node != root && node->color == BLACK)
	{
		if(node == node->parent->left)
		{
			Node *brother = node->parent->right;
			if(brother->color == RED)
			{
				brother->color = BLACK;
				node->parent->color = RED;
				LeftRotate(node->parent);
				brother = node->parent->right;	//此时brother的颜色为黑
			}
			if(brother->left->color == BLACK && brother->right->color == BLACK)
			{
				brother->color = RED;
				node = node->parent;
			}else{
				if(brother->right->color == BLACK) 
				{
					brother->color = RED;
					brother->left->color = BLACK;
					RightRotate(brother);
					brother = node->parent->right;
				}
				brother->color = node->parent->color;
				node->parent->color = brother->right->color = BLACK;
				LeftRotate(node->parent);
				node = root;
			}
		}else{
			Node *brother = node->parent->left;
			if(brother->color == RED)
			{
				brother->color = BLACK;
				node->parent->color = RED;
				RightRotate(node->parent);
				brother = node->parent->left;	//此时brother的颜色为黑
			}
			if(brother->left->color == BLACK && brother->right->color == BLACK)
			{
				brother->color = RED;
				node = node->parent;
			}else{
				if(brother->left->color == BLACK)
				{
					brother->color = RED;
					brother->right->color = BLACK;
					LeftRotate(brother);
					brother = node->parent->left;
				}
				brother->color = node->parent->color;
				node->parent->color = brother->left->color = BLACK;
				RightRotate(node->parent);
				node = root;
			}
		}
	}
	node->color = BLACK;
}
Node *RedBlackTree::Successor(Segment data)
{
	Node *node = Search(data);
	Node *result = nil;
	if(node->right != nil)
		result = Minimum(node->right);
	else{
		result = node->parent;
		while(result != nil && node == result->right)
		{
			node = result;
			result = result->parent;
		}
	}
	return result;
}
Node *RedBlackTree::Predecessor(Segment data)
{
	Node *node = Search(data);
	Node *result = nil;
	if(node->left != nil)
		result = Minimum(node->left);
	else{
		result = node->parent;
		while(result != nil && node == result->left)
		{
			node = result;
			result = result->parent;
		}
	}
	return result;
}
Node *RedBlackTree::Minimum(Node *node)
{
	while(node->left != nil)
		node = node->left;
	return node;
}
Node *RedBlackTree::Search(Segment data)
{
	Node *node = root;
	while(node != nil && node->data != data)
		if(data < node->data)
			node = node->left;
		else
			node = node->right;
	return node;
}
void RedBlackTree::LeftRotate(Node *x)	//函数默认x的右子树不是nil
{
	Node *y = x->right;
	//第一步
	x->right = y->left;
	if(y->left != nil)
		y->left->parent = x;
	//第二步
	y->parent = x->parent;
	if(x->parent == nil)
		root = y;
	else
		if(x == x->parent->left)
			x->parent->left = y;
		else
			x->parent->right = y;
	//第三步
	y->left = x;
	x->parent = y;
}
void RedBlackTree::RightRotate(Node *x)	//函数默认x的左子树不是nil
{
	Node *y = x->left;
	//第一步
	x->left = y->right;
	if(y->right != nil)
		y->right->parent = x;
	//第二步
	y->parent = x->parent;
	if(x->parent == nil)
		root = y;
	else
		if(x == x->parent->left)
			x->parent->left = y;
		else
			x->parent->right = y;
	//第三步
	y->right = x;
	x->parent = y;
}








void swap(Point *a,Point *b)
{
	int tmp = a->x; a->x = b->x; b->x = tmp;
	tmp = a->y; a->y = b->y; b->y = tmp;
	bool left = a->left; a->left = b->left; b->left = left;
}
void MaxHeap(Point *num,int pos,int total)
{
	int largest = pos;
	while(true)
	{
		if(pos*2 <= total && num[pos*2] > num[largest])
			largest = pos * 2;
		if(pos*2+1 <= total && num[pos*2+1] > num[largest])
			largest = pos *2 + 1;
		if(largest != pos)
		{
			swap(&num[largest],&num[pos]);
			pos = largest;
		}else
			break;
	}
}
void HeapSort(Point *num,int total)
{
	int i;
	for(i = total / 2; i != 0; i--)
		MaxHeap(num,i,total);
	int heapSize = total;
	for(i = heapSize; i != 1; i--)
	{
		swap(&num[1],&num[i]);
		heapSize--;
		MaxHeap(num,1,heapSize);
	}
}







void AnySegmentIntersect(Segment segment[],int n)
{
	Point point[2 * n + 1];
	int i;
	for(i = 1; i <= n; i++)
	{
		point[i].x = segment[i-1].left.x;
		point[i].y = segment[i-1].left.y;
		point[i].left = true;
		point[i + n].x = segment[i-1].right.x;
		point[i + n].y = segment[i-1].right.y;
		point[i + n].left = false;
		point[i].s = point[i + n].s = &segment[i-1];
	}
	HeapSort(point,2*n+1);
	RedBlackTree tree;
void Insert(int data);
void Delete(int data);
Node *Search(int data);
Node *Successor(int data);
Node *Predecessor(int data);


	for(i = 1; i <= 2 * n; i++)
	{
		if(point[i].left == true)
		{
			tree.Insert(point[i].s);
		}
	}
}
int main()
{
}
